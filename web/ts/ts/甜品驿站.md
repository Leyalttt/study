##### 创建vue3

cmd->npm init vue

vue3-ts-h5

使用ts, 使用jsx 使用router, 使用pinia, 不适用unit, 不适用end, 使用eslint, 使用pretter

cd到vue3-ts-h5

npm install

code . 打开vscode



##### git管理

git init 初始化

git add .

git commit -m 'first-commit'

码云里创建项目

```
git remote add origin https://gitee.com/tao-tingting/vue3-ts-h5.git
```

```
git push -u origin "master" 提交
git pull origin "master" 拉取
```

npm run dev



##### eslint的使用

1.在运行代码前就发现语法错误和潜在的bug

2.非常适合用于制定团队代码规范

3.eslint的规则分三个等级

​	off
​	warn
​	error



##### 什么是prettier

代码格式化工具，用于检测代码中的格式问题

eslint偏向于把控项目代码的质量，而prettier更偏向于统一项目的编码风格

```js
"semi":fa1se,// 不需要分号结束"tcabwidth":2，// tab使用两个空格
"singleQuote":true，//单引号
"printwidth":100，//单行代码字行数量不能超过100"trailingcomma"":"none"// 对象后面默认添加逗号
```

npm install vant -S

使用vant4



##### 使用json-server搭建mockserver

1.为什么要学习
经常要使用mock来模拟后端的数据 提供数据接口
2.学习内容
介绍mockserver和jsonservervue3-ts-h5的server 架构json-server搭建mockserver
3.什么是mockserver
轻量级的本地模拟数据的服务器
4.什么是json-server
mockserver的搭建工具
可以轻易搭建拥有完整的restful的轻量级后端服务
使用jspn-server的方式
通过json-server命令启动一个服务
通过module将json-server引l入到自己的nod服务



1v1->mkdir vue3-ts-server

cd vue3-ts-server

npm init

npm install json-server -S

npm run server

npm install nodemon -S



##### 跨域配置

参考vite官网->服务器选项

写在vite.config.ts

```ts
server: {
    proxy: {
      '/api': {
        target: 'http://127.0.0.1:9000'
      }
    }
  }
```



npm install axios -S





##### axios请求以及拦截



##### 移动端适配

常用适配方案

- 不同端使用不同代码，比如 PC端一套代码，移动端一套代码
- 不同端使用同一套代码，一般使用 CSS 样式来控制
  @media
- 移动端屏幕适配
  - 利用 rem 按根节点(body)的字体大小来缩放
  - 利用 vh/vw 按屏幕高度和宽度来缩放

##### rem适配

- rem 是跟 px 类似的 CSS 数量单位当前属性大小值按根节点 body 的 font-size 等比例计算
  16px = 1 rem

- 将 css 属性单位从 px 改为 rem

- 动态获取用户设备的屏幕宽度

  fontSize(body)=width(屏幕)*fontSize(设计稿中的body)/width(设计稿中的屏幕)

- px转rem

  rem(css属性)=pz(css属性)/pz(body的fontSize)

  

##### post-css css的转换工具

- autopreixer自动管理css属性的浏览器前缀

- epostcss-pxtorem:px转换成rem
  1.npm install postcss autoprefixer postcss-pxtorem -D
  2.新建postcss.config.js

  ```js
  module.exports = {
    plugins: {
    autoprefixer: {
    overrideBrowserslist:['Android >= 4.0'，'ios > 7']
    },
    'postcss-pxtorem': {//根节点的 fontsize的值
      rootvalue: 16,
      propList: ['*'],
      selectorBlackList: [':root']
  	}
    }
  }
  
  ```

  main.ts里写适配

  ```js
  const rootValue = 16
  const rootWidth = 390
  //获取屏幕宽度
  const deviceWidth = document.documentElement.clientWidth
  document.documentElement.style.fontSize = (deviceWidth * rootValue) / rootWidth + 'px'
  ```



##### vant按需引入和全局引入

1.常规用法

```js

```

2.按需引入

安装插件npm i @vant/auto-import-resolver unplugin-vue-components -D

配置vite.config.js

```js
import Components from 'unplugin-vue-components/vite';
import { VantResolver } from '@vant/auto-import-resolver';
export default {
  plugins: [
    vue(),
    Components({
      resolvers: [VantResolver()],
    }),
  ],
};
```



##### 页面头部实现

1.安装css预处理器sass和处理不同浏览器的默认样式normalize.css

npm install normalize.css

npm install sass -D

2.app.vue中css样式

```css
<style scoped>
@import 'normalize.css';
#app {
  /**字体抗锯齿，让字体看起来更清晰*/
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  color: #2c3e50;
  font-size: 14px;
}
</style>
```



##### 防抖优化解决搜索的问题

短时间内多次发送请求，造成返回结果的不正确
发送无用的请求，占用资源

- 防抖 在一段时间内出发多次 只执行最后一次
  	1.将事件延时执行
    	2.如果这段时间内事件再次被触发的话 则取消执行之前的事件



##### 自定义hooks-useAsync实现请求处理

Promise then 和 catch 的处理
TS 声明复杂的类型结构
使用 jsonserver 中间件延时返回数据
新建一个 fetchHomePageData 的 api
实现 useAsync，将 api 包裹一层，处理 Promise 的状态



##### 后台数据获取

1. data->homedata.js

2. src->db.js

​	require引入homedata.js-> module.exports 调用, 外面包裹一层处理状态

```js
const test = require('../data/test')
const homePage = require('../data/homedata')
function responseData(data) {
  return {
    code: 200,
    msg: '请求成功',
    data
  }
}
module.exports = ()=> {
  return {
    testjson: test(),
    homePage: responseData(homePage())
  }
}
```

3. app.js中间件

```js
server.use((req, res, next)=> {
  setTimeout(next, 1000)
})
```



##### loading组件封装



##### transform组件的实现

##### Grid 布局即网格布局

grid-template-columns 属性设置列宽

```css
/* 5列大小站一份 */
grid-template-columns: repeat(5, 1fr);
```

##### 限时抢购

两位数补零

```js
const padStart = (num: number)=> {
  return num.toString().padStart(2, "0")
}
```



##### requestAnimationFrame 介绍

- window.requestAnimationFrame0) 告诉浏览器一一你希望执行一个动画，并且要求浏览器在下次币绘之前调用指定的回洞函数更新动画，该方法需要传入一个回调勇数作为参数，该回调函数会在浏览器下一次币绘之前执行

- 语法

  ```
  window.requestAnimationFrare(ca17back);
  ```

  参数:

  calback:下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimestamp 参数，该参数表示 requestAnimationFTame()开始去执行回调的数的时刻

  返回值:
  一个long整数，请求 I，是回调列表中唯一的标识，是个非零值，没别的意义。你可以传这个值给 window.cancelAnimationFrame0以取消回调函数。

- 使用

```js
<script>
window.onload = function(){
function test() {
  console.1og("requestAnimationFrame");
}
	reauestAnimationFrame(test):
</script>
```

疑问?但是它只执行了一次，怎么做动画呢?别急，再看看 MDN 怎么说。注意:若你想在浏览器下次重绘之前继续更新下一锁动画，那么回调函致自身必须再次调用window.requestAnimationframe()

```js
window.onload = function(){
 var n = 0;
 function test(){
  n++;
	conso1e.1og("requestAnimationFrame ----",n)
  requestAnimationFrame(test);
 }
requestAnimationFrame(test);
}
```



- 执行频率

  回调函数执行次数通常是每秒 60次，但在大多数道循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕剧新次数相匹配即不用手动设置执行间隔时间，而是根据 汶器屏蒂刷新次数 自动调整了,也就是说浏览器屏幕剧新多少次，它就执行多少次，

- 回调函数参数
  在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时问戳，即使在计算上一个回调的数的工作负载期间己经消耗了一些时问，该时间戳是一个十进制数，单位毫秒，最小精度为1ms(1000us),

  ```js
      window.onload = function() {
        function test(timeStamp) {
          console.log('requestAnimationFrame------', timeStamp)
          requestAnimationFrame(test)
        }
        requestAnimationFrame(test)
      }
  ```

  可以看出每次执行隔间时间戳近似等于1000 / 60 = 16.666 毫秒

  ##### 如果有多个 requestAnimationFrame 一起执行会怎样?

  ```js
      window.onload = function() {
        function test1(timeStamp) {
          console.log('requestAnimationFrame------', timeStamp)
          requestAnimationFrame(test1)
        }
        
        function test2(timeStamp) {
          console.log('requestAnimationFrame------', timeStamp)
          requestAnimationFrame(test2)
        }
        requestAnimationFrame(test1)
        requestAnimationFrame(test2)
      }
  ```

  可以看到，两个requestAnimationFrame 在控制台输出的时间戳是一样的。也就是浏览器剧新一次的时候，执行所有的requestAnimationFrame ，并且它们的回调参数是一一样的。

  

  ##### 返回值

  每执行一次，数值就会 +1

  ```js
  window.onload = function() {
  var startBtn = document.querySelector("#start")
        var rAF
        startBtn.addEventListener("click", ()=> {
          rAF = requestAnimationFrame(test)
        })
  
        function test() {
          rAF = requestAnimationFrame(test)
          console.log("rAF:", rAF)
        }
  ```

  ##### 取消执行

  传这个值给 window.cancelAnimationFrame() 以取消回调函数

  ```js
  window.onload = function() {
  var startBtn = document.querySelector("#start")
            stopBtn = document.querySelector("#stop")
        var rAF
        startBtn.addEventListener("click", ()=> {
          rAF = requestAnimationFrame(test)
        })
        stopBtn.addEventListener("click", ()=> {
          cancelAnimationFrame(rAF)
        })
  
        function test() {
          rAF = requestAnimationFrame(test)
          console.log("rAF:", rAF)
        }
      }
  ```



##### 实现一个动画

```css
#box {
  width: 0;
  height: 50px;
  background-color: tomato;
}
```

```html
<button id="start">开始执行</button>
<button id="stop">结束执行</button>
<div id="box"></div>
```

```js
    window.onload = function() {
    var startBtn = document.querySelector("#start")
        stopBtn = document.querySelector("#stop")
        box = document.querySelector("#box")
      var rAF
      startBtn.addEventListener("click", ()=> {
        rAF = requestAnimationFrame(test)
      })
      stopBtn.addEventListener("click", ()=> {
        cancelAnimationFrame(rAF)
      })

      function test() {
        box.style.width = `${rAF}%`
        rAF = requestAnimationFrame(test)
      }
    }
```



##### 封装hooks

use->useCountDown.ts->

```ts

```

